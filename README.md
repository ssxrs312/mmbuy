# mmbuy
目录结构，包括7个工程
eureka-service：注册中心;
config-service：配置中心;
user-service：用户工程;
trade-service：交易工程;
stock-service：库存工程;
schedule-service：分布式调度任务;
keygen-service：唯一ID生成服务

![image-20190707170340613](http://ww4.sinaimg.cn/large/006tNc79ly1g4re6emgikj308p04xwex.jpg)

# 1  maven聚合工程创建

`maven`聚合工程的创建，创建`eureka`注册中心服务端（`mmbuy-eureka-service`），还可能涉及其他的组件，比如`fiegn`接口调用、`zuul`网关实现（未实现）、`stream`消息驱动、`sleuth`链路追踪（这里也没去追踪）、`hystrix`服务降级和熔断（没有去做）、`spring security`实现用户信息校验

# 2 消息总线

spring-cloud-config+zookeeper+kafka+actuator做成一个消息总线，自动从git上拉取配置并刷新,mmbuy-config-server

# 3 分库分表

`shardingJDBC`分库分表中间件的使用

# 4 全局异常处理

对异常进行统一的处理，解决潜在异常以及自己不停捕获异常导致代码的不优雅。

# 5 分布式session管理

`spring session`+`redis`实现分布式`session`管理，并且探讨了实现原理

# 6 ZK分布式锁

由用户注册问题，延申出如何防止用户名注册重复问题，这里由于是分布式+分表的情况，所以`select...for update`以及唯一索引都不再适用本场景，这里使用`curator`客户端实现的ZK分布式锁。并且探讨了ZK分布式锁的基本原理

# 7 分布式ID生成

对于分布式ID生成问题，核心点为：唯一+有序，前者要求是必须全局唯一的，后者是基于mysql的存储引擎如何提高查询效率而提出的要求。本文采用`snowflake`算法来实现。`mmbuy-keygen-service`

# 8 全文检索

关于商品信息的全文搜索（搜索框或者点击分类显示这个分类下的所有商品），数据库的模拟查询限制太多：速度慢、匹配问题、全表扫描等问题，这里搭建ELK平台（Elasticsearch、Logstash和Kibana），对商品表的内容进行建立索引，再加上分词器`ik_max_word`，对匹配结果进行排序，展示出来。这里详细说明了ELK平台的搭建过程和测试。最后用`Jest`,客户端编写java代码，在代码层面实现全文搜索功能。

# 9 缓存

`spring cache`的基本使用，对于简单的缓存场景可以用这个。

# 10 下单扣减库存引起的超卖问题解决

针对用户下单扣减库存问题，详细探讨了普通update存在超卖的问题，后续一系列的优化：

- 乐观锁（多线程竞争性能低）；
- 悲观锁（性能低，直接锁行，需要排队）；
- `redis`的`watch`实现的乐观锁，不过`watch`不能再集群环境下使用，限制较多；
- 用`incrby`原子递增或者递减操作，对于一个变量可以这样实现，但是库存一般都要维护两个变量：库存+锁定库存，前者表示还剩多少库存没有被下单，也没有被支付，是真正可以利用的库存；后者表示被下单的库存，但是还没有支付，如果订单超时，是需要将其收回的。所以一个原子操作是不够的，我们需要一个办法让这两个变量的变化放在一个事务里面。
- 引出了本文的实现方案：`redis`+`lua`脚本。为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。`lua`脚本在`redis`中执行是串行的、原子性的。

# 11 幂等性问题

幂等性问题：用户下单除了由于多线程竞争引发超卖问题之外，还有一个问题是幂等性问题，因为下订单往往是通过MQ去异步下订单，如果MQ出现问题，于是进行了重发机制，最后可能导致两次或两次以上去下订单成功，那么一个用户明明就买了一个商品，结果扣掉了两件商品，是不能忍受的。如何解决呢？这里是采用`redis`分布式锁来锁订单号一段时间来解决的。让他在一段时间内锁住，防止由于MQ重发机制导致重复进来扣减库存。由于锁的是每一个订单号，所以性能不会受到影响，一段时间后让锁自动过期失效。

# 12 定时任务

定时任务，这里采用分布式定时任务`Elastic Job`来实现，这里详细介绍了如何整合，此外，定时任务用处非常多，比如这里用定时任务是扫描哪些订单是超时的，可以去扫描出来去关闭。还有就是，下订单一般是先下到订单流水表中，后面慢慢通过定时任务同步到订单表中，这样可以记录一些中间状态的详细信息，出现问题也可以从这个表中找出一些原因。

# 13 redis事件通知

下完订单后可以利用`redis`过期事件回调通知来提高订单超时解决的效率，提早将库存归位，定时扫描再检查。

# 14 分布式事务解决方案

复杂的业务场景往往会设计跨库操作，比如多个数据库，比如`redis`和数据库等等，如何保证数据的一致性呢？介绍了两种可行性方案：基于可靠消息服务的分布式事务（目前只有`RocketMQ`消息队列可以实现）和最大努力通知。我们追求的是数据的最终一致性，所以可以容许中间状态的存在。

